#pragma kernel PerlinNoise3D

#include "CoreRP/ShaderLibrary/Common.hlsl"

RWTexture3D<half> _NoiseTexture;

cbuffer noiseSettings
{
	float3 chunkPosition;
	float3 chunkSize;
	float seed;
	int octaves;
	float lacunarity;
	float scale;
}

float hash(float h) {
	return frac(sin(h) * 43758.5453123);
}

float noise(float3 x) {
	float3 p = floor(x);
	float3 f = frac(x);
	f = f * f * (3.0 - 2.0 * f);

	float n = p.x + p.y * 157.0 + 113.0 * p.z;
	return lerp(
			lerp(lerp(hash(n + 0.0), hash(n + 1.0), f.x),
					lerp(hash(n + 157.0), hash(n + 158.0), f.x), f.y),
			lerp(lerp(hash(n + 113.0), hash(n + 114.0), f.x),
					lerp(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);
}

float fbm(float3 p) {
	float f = 0.0;
	float localLacunarity = lacunarity;
	int i;

	for (i = 0; i < octaves; i++)
	{
		f = rcp(pow(2, (i + 1))) * noise(p);
		p *= 2 + localLacunarity;
		localLacunarity += 0.01;
	}

	return f;
}

[numthreads(1, 1, 1)]
void PerlinNoise3D(uint3 id : SV_DispatchThreadID)
{
	float3 worldNoisePosition = float3(id - 1.0) * rcp(chunkSize - 2.0) + chunkPosition;

	// Return a random number between -1 and 1
	float f = fbm(worldNoisePosition * scale + seed * float3(55.485615, -534.6543684, 6.465342)) * 2 - 1;
	_NoiseTexture[id] = lerp(-2, f, float(chunkSize.y - id.y) / chunkSize.y * 2 + 0.5);
	
	// Debug Sphere:
	// _NoiseTexture[id] = length(worldNoisePosition - 0.4) - 0.3;
}
