// Marching cubes algorithm from https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html

#pragma kernel MarchingCubes

#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "MarchingCubeConstants.hlsl"

Texture3D<half> _NoiseTexture;
SamplerState sampler_NoiseTexture;
Texture3D<half3> _NormalTexture;
SamplerState sampler_NormalTexture;
float3 chunkSize;

RWTexture3D<half> _DebugOutput;

RWStructuredBuffer<half3> vertices;
RWStructuredBuffer<half3> normals;
RWStructuredBuffer<int> triangles;
RWStructuredBuffer<int> triangleCounter;

float3 PlaceVerticeOnEdge(float3 voxelPosition, float4 f0123, float4 f4567, int edgeNum)
{
	float str0 = dot(GetCornerAmask0123(edgeNum), f0123) + dot(GetCornerAmask4567(edgeNum), f4567);
	float str1 = dot(GetCornerBmask0123(edgeNum), f0123) + dot(GetCornerBmask4567(edgeNum), f4567);
	float t = saturate(str0 / (str0 - str1));

	float3 posCell = GetEdgeStart(edgeNum) + t * GetEdgeDir(edgeNum);
	float3 wsPos = voxelPosition + posCell * chunkSize;

	return wsPos;
}

static float _Target = 0;
static float _Border = 0;

static int2 edgeConnection[12] =
{
	int2(0,1), int2(1,2), int2(2,3), int2(3,0), int2(4,5), int2(5,6), int2(6,7), int2(7,4), int2(0,4), int2(1,5), int2(2,6), int2(3,7)
};

// edgeDirection lists the direction vector (vertex1-vertex0) for each edge in the cube
static float3 edgeDirection[12] =
{
	float3(1.0f, 0.0f, 0.0f),float3(0.0f, 1.0f, 0.0f),float3(-1.0f, 0.0f, 0.0f),float3(0.0f, -1.0f, 0.0f),
	float3(1.0f, 0.0f, 0.0f),float3(0.0f, 1.0f, 0.0f),float3(-1.0f, 0.0f, 0.0f),float3(0.0f, -1.0f, 0.0f),
	float3(0.0f, 0.0f, 1.0f),float3(0.0f, 0.0f, 1.0f),float3(0.0f, 0.0f, 1.0f),float3(0.0f,  0.0f, 1.0f)
};

// vertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube
static float3 vertexOffset[8] =
{
	float3(0, 0, 0),float3(1, 0, 0),float3(1, 1, 0),float3(0, 1, 0),
	float3(0, 0, 1),float3(1, 0, 1),float3(1, 1, 1),float3(0, 1, 1)
};

float3 ComputeNormal(float3 uvw)
{
	float4 step = float4(1.0 / chunkSize, 0);
	float3 gradient = float3(
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, uvw + step.xww, 0) - SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, uvw - step.xww, 0),
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, uvw + step.wwy, 0) - SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, uvw - step.wwy, 0),
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, uvw + step.wzw, 0) - SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, uvw - step.wzw, 0)
	);
	
	return normalize(-gradient);
}

void FillCube(int x, int y, int z, out float cube[8])
{
	cube[0] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3(x, y, z) / chunkSize, 0);
	cube[1] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3((x + 1), y, z) / chunkSize, 0);
	cube[2] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3((x + 1), (y + 1), z) / chunkSize, 0);
	cube[3] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3(x, (y + 1), z) / chunkSize, 0);

	cube[4] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3(x, y, (z + 1)) / chunkSize, 0);
	cube[5] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3((x + 1), y, (z + 1)) / chunkSize, 0);
	cube[6] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3((x + 1), (y + 1), (z + 1)) / chunkSize, 0);
	cube[7] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, float3(x, (y + 1), (z + 1)) / chunkSize, 0);
}

// GetOffset finds the approximate point of intersection of the surface
// between two points with the values v1 and v2
float GetOffset(float v1, float v2)
{
	float delta = v2 - v1;
	return (delta == 0.0f) ? 0.5f : (_Target - v1) / delta;
}

void CreateVertex(float3 position, float3 centre, float3 size, int index)
{
	float3 pos = position - centre;
	vertices[index] = pos;
	float3 uvw = pos / size;
	normals[index] = SAMPLE_TEXTURE3D_LOD(_NormalTexture, sampler_NormalTexture, uvw, 0);
}

[numthreads(1,1,1)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
	float3 voxelUVW = float3(id) / chunkSize;
	_DebugOutput[id] = SAMPLE_TEXTURE3D_LOD(_NormalTexture, sampler_NormalTexture, voxelUVW, 0);

	float3 pos = float3(id);
	float3 centre = float3(chunkSize.x, 0, chunkSize.z) / 2.0;

	float cube[8];
	FillCube(id.x, id.y, id.z, cube);
	float3 normal = ComputeNormal(id);

	int i = 0;
	int flagIndex = 0;
	float3 edgeVertex[12];

	//Find which vertices are inside of the surface and which are outside
	for (i = 0; i < 8; i++)
		if (cube[i] <= _Target) flagIndex |= 1 << i;

	//Find which edges are intersected by the surface
	int edgeFlags = GetCubeEdgeFlags(flagIndex);

	// no connections, return
	if (edgeFlags == 0) return;

	//Find the point of intersection of the surface with each edge
	for (i = 0; i < 12; i++)
	{
		//if there is an intersection on this edge
		if ((edgeFlags & (1 << i)) != 0)
		{
			float offset = GetOffset(cube[edgeConnection[i].x], cube[edgeConnection[i].y]);

			edgeVertex[i] = pos + (vertexOffset[edgeConnection[i].x] + offset * edgeDirection[i]);
		}
	}

	float3 size = float3(chunkSize.x - 1, chunkSize.y - 1, chunkSize.z - 1);

	int idx = id.x + id.y * chunkSize.x + id.z * chunkSize.x * chunkSize.y;

	//Save the triangles that were found. There can be up to five per cube
	for (i = 0; i < 5; i++)
	{
		//If the connection table is not -1 then this a triangle.
		if (GetTriTable2(flagIndex * 16 + 3 * i) >= 0)
		{
			float3 position;

			int triangleCount = triangleCounter.IncrementCounter() * 3;

			position = edgeVertex[GetTriTable2(flagIndex * 16 + (3 * i + 0))];
			CreateVertex(position, centre, size, triangleCount + 0);

			position = edgeVertex[GetTriTable2(flagIndex * 16 + (3 * i + 1))];
			CreateVertex(position, centre, size, triangleCount + 1);

			position = edgeVertex[GetTriTable2(flagIndex * 16 + (3 * i + 2))];
			CreateVertex(position, centre, size, triangleCount + 2);

			triangles[triangleCount + 0] = triangleCount + 0;
			triangles[triangleCount + 1] = triangleCount + 1;
			triangles[triangleCount + 2] = triangleCount + 2;
		}
	}

}