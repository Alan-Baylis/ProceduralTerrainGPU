// Marching cubes algorithm from https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html

#pragma kernel MarchingCubes

#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "MarchingCubeConstants.hlsl"

Texture3D<half> _NoiseTexture;
SamplerState sampler_NoiseTexture;
float3 chunkSize;

RWTexture3D<half> _DebugOutput;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<int> triangles;
RWStructuredBuffer<int> triangleCounter;

float3 PlaceVerticeOnEdge(float3 voxelPosition, float4 f0123, float4 f4567, int edgeNum)
{
	float str0 = dot(GetCornerAmask0123(edgeNum), f0123) + dot(GetCornerAmask4567(edgeNum), f4567);
	float str1 = dot(GetCornerBmask0123(edgeNum), f0123) + dot(GetCornerBmask4567(edgeNum), f4567);
	float t = saturate(str0 / (str0 - str1));

	float3 posCell = GetEdgeStart(edgeNum) + t * GetEdgeDir(edgeNum);
	float3 wsPos = voxelPosition + posCell * chunkSize;

	return wsPos;
}

[numthreads(1,1,1)]
void MarchingCubes (uint3 id : SV_DispatchThreadID)
{
	float3 voxelPosition = id;
	float2 step = float2(1 / chunkSize.x, 0);
	float3 voxelUVW = voxelPosition / chunkSize;

	_DebugOutput[id] = SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.yyy, 0);

	float4 f0123 = float4(
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.yyy, 0).x,
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.yyx, 0).x,
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.xyx, 0).x,
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.xyy, 0).x
	);
	
	float4 f4567 = float4(
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.yxy, 0).x,
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.yxx, 0).x,
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.xxx, 0).x,
		SAMPLE_TEXTURE3D_LOD(_NoiseTexture, sampler_NoiseTexture, voxelUVW + step.xxy, 0).x
	);

	uint4 n0123 = (uint4)saturate(f0123 * 99999);
	uint4 n4567 = (uint4)saturate(f4567 * 99999);
	uint mc_case = (n0123.x     ) | (n0123.y << 1) | (n0123.z << 2) | (n0123.w << 3)
				 | (n4567.x << 4) | (n4567.y << 5) | (n4567.z << 6) | (n4567.w << 7);

	uint num_polys = GetCaseToNumpolys(mc_case);
	uint table_pos = mc_case * 5;

#if 1

	for (uint p = 0; p < num_polys; p++)
	{
		// TODO: this may not be the best way to do geometry generation
		int3 polydata = GetTriTable(table_pos++);

		int triangleCount = triangleCounter.IncrementCounter() * 3;
		
		vertices[triangleCount + 0] = PlaceVerticeOnEdge(voxelPosition, f0123, f4567, polydata.x);
		vertices[triangleCount + 1] = PlaceVerticeOnEdge(voxelPosition, f0123, f4567, polydata.y);
		vertices[triangleCount + 2] = PlaceVerticeOnEdge(voxelPosition, f0123, f4567, polydata.z);

		triangles[triangleCount + 0] = triangleCount + 0;
		triangles[triangleCount + 1] = triangleCount + 1;
		triangles[triangleCount + 2] = triangleCount + 2;
	}

#else

	/*
	Triangle:
	p4  p3
	| / |
	p1--p2
	*/
	
	int triangleCount = triangleCounter.IncrementCounter() * 3;

	float3 p1 = float3(0, 0, 0) + id;
	float3 p2 = float3(1, 0, 0) + id;
	float3 p3 = float3(1, 1, 0) + id;
	float3 p4 = float3(0, 1, 0) + id;

	vertices[triangleCount + 0] = (p1);
	vertices[triangleCount + 1] = (p2);
	vertices[triangleCount + 2] = (p3);
	
	triangles[triangleCount + 0] = triangleCount + 0;
	triangles[triangleCount + 1] = triangleCount + 1;
	triangles[triangleCount + 2] = triangleCount + 2;

	triangleCount = triangleCounter.IncrementCounter() * 3;

	vertices[triangleCount + 0] = (p1);
	vertices[triangleCount + 1] = (p3);
	vertices[triangleCount + 2] = (p4);
	
	triangles[triangleCount + 0] = triangleCount + 0;
	triangles[triangleCount + 1] = triangleCount + 1;
	triangles[triangleCount + 2] = triangleCount + 2;

#endif
}